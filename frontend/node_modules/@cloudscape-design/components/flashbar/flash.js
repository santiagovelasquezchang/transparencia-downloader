import { __rest } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useRef } from 'react';
import clsx from 'clsx';
import { useComponentMetadata, useMergeRefs, useUniqueId, warnOnce, } from '@cloudscape-design/component-toolkit/internal';
import { getAnalyticsMetadataAttribute } from '@cloudscape-design/component-toolkit/internal/analytics-metadata';
import { ActionsWrapper } from '../alert/actions-wrapper';
import { InternalButton } from '../button/internal';
import InternalIcon from '../icon/internal';
import { DATA_ATTR_ANALYTICS_FLASHBAR, DATA_ATTR_ANALYTICS_SUPPRESS_FLOW_EVENTS, } from '../internal/analytics/selectors';
import { getVisualContextClassname } from '../internal/components/visual-context';
import { PACKAGE_VERSION } from '../internal/environment';
import customCssProps from '../internal/generated/custom-css-properties';
import { isDevelopment } from '../internal/is-development';
import { awsuiPluginsInternal } from '../internal/plugins/api';
import { createUseDiscoveredAction, createUseDiscoveredContent } from '../internal/plugins/helpers';
import { throttle } from '../internal/utils/throttle';
import useContainerWidth from '../internal/utils/use-container-width';
import InternalLiveRegion from '../live-region/internal';
import InternalSpinner from '../spinner/internal';
import { getItemStyles } from './collapsible-flashbar';
import { FOCUS_THROTTLE_DELAY } from './utils';
import analyticsSelectors from './analytics-metadata/styles.css.js';
import styles from './styles.css.js';
const ICON_TYPES = {
    success: 'status-positive',
    warning: 'status-warning',
    info: 'status-info',
    error: 'status-negative',
    'in-progress': 'status-in-progress',
};
const useDiscoveredAction = createUseDiscoveredAction(awsuiPluginsInternal.flashbar.onActionRegistered);
const useDiscoveredContent = createUseDiscoveredContent('flash', awsuiPluginsInternal.flashContent);
function dismissButton(dismissLabel, onDismiss, style) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    return (React.createElement("div", Object.assign({ className: styles['dismiss-button-wrapper'] }, getAnalyticsMetadataAttribute({
        action: 'dismiss',
    })),
        React.createElement(InternalButton, { onClick: onDismiss, className: styles['dismiss-button'], variant: "flashbar-icon", iconName: "close", formAction: "none", ariaLabel: dismissLabel, style: {
                root: {
                    color: {
                        active: (_c = (_b = (_a = style === null || style === void 0 ? void 0 : style.item) === null || _a === void 0 ? void 0 : _a.dismissButton) === null || _b === void 0 ? void 0 : _b.color) === null || _c === void 0 ? void 0 : _c.active,
                        default: (_f = (_e = (_d = style === null || style === void 0 ? void 0 : style.item) === null || _d === void 0 ? void 0 : _d.dismissButton) === null || _e === void 0 ? void 0 : _e.color) === null || _f === void 0 ? void 0 : _f.default,
                        hover: (_j = (_h = (_g = style === null || style === void 0 ? void 0 : style.item) === null || _g === void 0 ? void 0 : _g.dismissButton) === null || _h === void 0 ? void 0 : _h.color) === null || _j === void 0 ? void 0 : _j.hover,
                    },
                    focusRing: {
                        borderColor: (_m = (_l = (_k = style === null || style === void 0 ? void 0 : style.item) === null || _k === void 0 ? void 0 : _k.dismissButton) === null || _l === void 0 ? void 0 : _l.focusRing) === null || _m === void 0 ? void 0 : _m.borderColor,
                        borderRadius: (_q = (_p = (_o = style === null || style === void 0 ? void 0 : style.item) === null || _o === void 0 ? void 0 : _o.dismissButton) === null || _p === void 0 ? void 0 : _p.focusRing) === null || _q === void 0 ? void 0 : _q.borderRadius,
                        borderWidth: (_t = (_s = (_r = style === null || style === void 0 ? void 0 : style.item) === null || _r === void 0 ? void 0 : _r.dismissButton) === null || _s === void 0 ? void 0 : _s.focusRing) === null || _t === void 0 ? void 0 : _t.borderWidth,
                    },
                },
            } })));
}
export const focusFlashById = throttle((element, itemId) => {
    var _a;
    const selector = `[data-itemid="${CSS.escape(itemId)}"] .${styles['flash-focus-container']}`;
    (_a = element === null || element === void 0 ? void 0 : element.querySelector(selector)) === null || _a === void 0 ? void 0 : _a.focus();
}, FOCUS_THROTTLE_DELAY, { trailing: false });
export const Flash = React.forwardRef((_a, ref) => {
    var _b, _c, _d, _e, _f, _g, _h, _j;
    var { id, header, content, dismissible, dismissLabel, loading, action, buttonText, onButtonClick, onDismiss, className, transitionState, ariaRole, i18nStrings, type = 'info', analyticsMetadata, style } = _a, props = __rest(_a, ["id", "header", "content", "dismissible", "dismissLabel", "loading", "action", "buttonText", "onButtonClick", "onDismiss", "className", "transitionState", "ariaRole", "i18nStrings", "type", "analyticsMetadata", "style"]);
    if (isDevelopment) {
        if (buttonText && !onButtonClick) {
            warnOnce('Flashbar', `You provided a \`buttonText\` prop without an \`onButtonClick\` handler. This will render a non-interactive action button.`);
        }
        if (dismissible && !onDismiss) {
            warnOnce('Flashbar', `You have set the \`dismissible\` prop without an \`onDismiss\` handler. This will render a non-interactive dismiss button.`);
        }
    }
    const [containerWidth, containerMeasureRef] = useContainerWidth();
    const elementRef = useComponentMetadata('Flash', PACKAGE_VERSION, analyticsMetadata);
    const mergedRef = useMergeRefs(ref, elementRef, containerMeasureRef);
    const flashIconId = useUniqueId('flash-icon');
    const flashMessageId = useUniqueId('flash-message');
    const headerRefObject = useRef(null);
    const contentRefObject = useRef(null);
    const { discoveredActions, headerRef: headerRefAction, contentRef: contentRefAction } = useDiscoveredAction(type);
    const { initialHidden, headerReplacementType, contentReplacementType, headerRef: headerRefContent, contentRef: contentRefContent, replacementHeaderRef, replacementContentRef, } = useDiscoveredContent({ type, header, children: content });
    const headerRef = useMergeRefs(headerRefAction, headerRefContent, headerRefObject);
    const contentRef = useMergeRefs(contentRefAction, contentRefContent, contentRefObject);
    const statusIconAriaLabel = props.statusIconAriaLabel ||
        (i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings[`${loading || type === 'in-progress' ? 'inProgress' : type}IconAriaLabel`]);
    const iconType = ICON_TYPES[type];
    const icon = loading ? (React.createElement("span", { role: "img", "aria-label": statusIconAriaLabel },
        React.createElement(InternalSpinner, null))) : (React.createElement(InternalIcon, { name: iconType, ariaLabel: statusIconAriaLabel }));
    const effectiveType = loading ? 'info' : type;
    const analyticsAttributes = {
        [DATA_ATTR_ANALYTICS_FLASHBAR]: effectiveType,
    };
    if (analyticsMetadata === null || analyticsMetadata === void 0 ? void 0 : analyticsMetadata.suppressFlowMetricEvents) {
        analyticsAttributes[DATA_ATTR_ANALYTICS_SUPPRESS_FLOW_EVENTS] = 'true';
    }
    return (
    // We're not using "polite" or "assertive" here, just turning default behavior off.
    // eslint-disable-next-line @cloudscape-design/prefer-live-region
    React.createElement("div", Object.assign({ ref: mergedRef, role: ariaRole, "aria-live": ariaRole ? 'off' : undefined, "data-itemid": id, className: clsx(styles.flash, styles[`flash-type-${effectiveType}`], className, transitionState && {
            [styles.enter]: transitionState === 'enter',
            [styles.entering]: transitionState === 'entering',
            [styles.entered]: transitionState === 'entered',
            [styles.exit]: transitionState === 'exit',
            [styles.exiting]: transitionState === 'exiting',
            [styles.exited]: transitionState === 'exited',
        }, getVisualContextClassname(type === 'warning' && !loading ? 'flashbar-warning' : 'flashbar'), initialHidden && styles['initial-hidden']), style: Object.assign(Object.assign(Object.assign({}, (style && getItemStyles(style, effectiveType))), (((_c = (_b = style === null || style === void 0 ? void 0 : style.item) === null || _b === void 0 ? void 0 : _b.root) === null || _c === void 0 ? void 0 : _c.focusRing) && {
            [customCssProps.styleFocusRingBorderColor]: (_d = style.item.root.focusRing) === null || _d === void 0 ? void 0 : _d.borderColor,
            [customCssProps.styleFocusRingBorderRadius]: (_e = style.item.root.focusRing) === null || _e === void 0 ? void 0 : _e.borderRadius,
            [customCssProps.styleFocusRingBorderWidth]: (_f = style.item.root.focusRing) === null || _f === void 0 ? void 0 : _f.borderWidth,
        })), (((_j = (_h = (_g = style === null || style === void 0 ? void 0 : style.item) === null || _g === void 0 ? void 0 : _g.root) === null || _h === void 0 ? void 0 : _h.focusRing) === null || _j === void 0 ? void 0 : _j.borderRadius) && {
            [customCssProps.styleFocusRingBorderRadius]: style.item.root.focusRing.borderRadius,
        })) }, analyticsAttributes),
        React.createElement("div", { className: styles['flash-body'] },
            React.createElement("div", { className: styles['flash-focus-container'], tabIndex: -1, role: "group", "aria-labelledby": `${flashIconId} ${flashMessageId}` },
                React.createElement("div", { className: clsx(styles['flash-icon'], styles['flash-text']), id: flashIconId }, icon),
                React.createElement("div", { className: clsx(styles['flash-message'], styles['flash-text']), id: flashMessageId },
                    React.createElement("div", { className: clsx(styles['flash-header'], headerReplacementType !== 'original' ? styles.hidden : analyticsSelectors['flash-header']), ref: headerRef }, header),
                    React.createElement("div", { className: clsx(styles['header-replacement'], headerReplacementType !== 'replaced' && styles.hidden), ref: replacementHeaderRef }),
                    React.createElement("div", { className: clsx(styles['flash-content'], contentReplacementType !== 'original' ? styles.hidden : analyticsSelectors['flash-header']), ref: contentRef }, content),
                    React.createElement("div", { className: clsx(styles['content-replacement'], contentReplacementType !== 'replaced' && styles.hidden), ref: replacementContentRef }))),
            React.createElement(ActionsWrapper, { className: styles['action-button-wrapper'], testUtilClasses: {
                    actionSlot: styles['action-slot'],
                    actionButton: styles['action-button'],
                }, action: action, discoveredActions: discoveredActions, buttonText: buttonText, onButtonClick: onButtonClick, containerWidth: containerWidth, wrappedClass: styles['action-wrapped'] })),
        dismissible && dismissButton(dismissLabel, onDismiss, style),
        ariaRole === 'status' && (React.createElement(InternalLiveRegion, { sources: [statusIconAriaLabel, headerRefObject, contentRefObject] }))));
});
//# sourceMappingURL=flash.js.map