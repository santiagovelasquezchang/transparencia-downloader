import { __awaiter } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useLayoutEffect, useRef } from 'react';
import clsx from 'clsx';
import { nodeContains } from '@cloudscape-design/component-toolkit/dom';
import { getLogicalBoundingClientRect, useResizeObserver } from '@cloudscape-design/component-toolkit/internal';
import { useVisualRefresh } from '../internal/hooks/use-visual-mode';
import usePopoverPosition from './use-popover-position.js';
import styles from './styles.css.js';
export default function PopoverContainer({ position, trackRef, getTrack: externalGetTrack, trackKey, minVisibleBlockSize, arrow, children, zIndex, renderWithPortal, size, fixedWidth, variant, keepPosition, allowScrollToFit, allowVerticalOverflow, hideOnOverscroll, hoverArea, className, }) {
    const bodyRef = useRef(null);
    const contentRef = useRef(null);
    const popoverRef = useRef(null);
    const arrowRef = useRef(null);
    const isRefresh = useVisualRefresh();
    const getTrack = useRef(() => {
        if (trackRef) {
            return trackRef.current;
        }
        if (externalGetTrack) {
            return externalGetTrack();
        }
        throw new Error('Invariant violation: must provide either trackRef or getTrack.');
    });
    // Updates the position handler.
    const { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef, isOverscrolling } = usePopoverPosition({
        popoverRef,
        bodyRef,
        arrowRef,
        getTrack: getTrack.current,
        contentRef,
        allowScrollToFit,
        allowVerticalOverflow,
        preferredPosition: position,
        renderWithPortal,
        keepPosition,
        hideOnOverscroll,
        minVisibleBlockSize,
    });
    // Recalculate position when properties change.
    useLayoutEffect(() => {
        updatePositionHandler();
    }, [updatePositionHandler, trackKey]);
    // Recalculate position when content size changes.
    useResizeObserver(contentRef, () => {
        updatePositionHandler(true);
    });
    // Recalculate position on DOM events.
    useLayoutEffect(() => {
        /*
        This is a heuristic. Some layout changes are caused by user clicks (e.g. toggling the tools panel, submitting a form),
        and by tracking the click event we can adapt the popover's position to the new layout.
        */
        const controller = new AbortController();
        const onClick = (event) => __awaiter(this, void 0, void 0, function* () {
            if (
            // Do not update position if keepPosition is true.
            keepPosition ||
                // If the click was on the trigger, this will make the popover appear or disappear,
                // so no need to update its position either in this case.
                nodeContains(getTrack.current(), event.target)) {
                return;
            }
            // Do not update position if popover moved offscreen
            const popoverOffset = popoverRef.current && getLogicalBoundingClientRect(popoverRef.current);
            // istanbul ignore if - tested via integration tests
            if (!popoverOffset || popoverOffset.insetBlockStart < 0 || popoverOffset.insetBlockEnd > window.innerHeight) {
                return;
            }
            // Continuously update the popover position for one second to account for any layout changes
            // and animations. On browsers where `requestIdleCallback` is supported,
            // this runs only while the CPU is otherwise idle. In other browsers (mainly Safari), we call it
            // with a low frequency.
            const targetTime = performance.now() + 1000;
            while (performance.now() < targetTime) {
                if (controller.signal.aborted) {
                    break;
                }
                updatePositionHandler();
                if (typeof requestIdleCallback !== 'undefined') {
                    yield new Promise(r => requestIdleCallback(r));
                }
                else {
                    yield new Promise(r => setTimeout(r, 50));
                }
            }
        });
        const updatePositionOnResize = () => requestAnimationFrame(() => updatePositionHandler());
        const refreshPosition = () => requestAnimationFrame(() => positionHandlerRef.current());
        window.addEventListener('click', onClick, { signal: controller.signal });
        window.addEventListener('resize', updatePositionOnResize, { signal: controller.signal });
        window.addEventListener('scroll', refreshPosition, { capture: true, signal: controller.signal });
        return () => {
            controller.abort();
        };
    }, [hideOnOverscroll, keepPosition, positionHandlerRef, trackRef, updatePositionHandler]);
    return isOverscrolling ? null : (React.createElement("div", { ref: popoverRef, style: Object.assign(Object.assign({}, popoverStyle), { zIndex }), className: clsx(styles.container, isRefresh && styles.refresh, className) },
        React.createElement("div", { ref: arrowRef, className: clsx(styles[`container-arrow`], styles[`container-arrow-position-${internalPosition}`]), "aria-hidden": true }, arrow(internalPosition)),
        React.createElement("div", { ref: bodyRef, className: clsx(styles['container-body'], styles[`container-body-size-${size}`], {
                [styles['fixed-width']]: fixedWidth,
                [styles[`container-body-variant-${variant}`]]: variant,
            }) }, hoverArea ? (React.createElement("div", { className: styles['hover-area'] },
            React.createElement("div", { ref: contentRef }, children))) : (React.createElement("div", { ref: contentRef }, children)))));
}
//# sourceMappingURL=container.js.map